# 浏览器的渲染过程：聚焦可见内容

浏览器的渲染过程是 **「完整解析DOM树，但有选择地渲染可见内容」**，核心逻辑是：**先构建完整的DOM结构（为了JS操作和后续动态变化），再基于「可见性」筛选出需要渲染的元素，生成渲染树（Render Tree）进行布局和绘制**。

---

### 一、先明确两个核心概念：DOM树 vs 渲染树

#### 1. DOM树（Document Object Model）：完整解析，一个都不能少

- **生成方式**：浏览器从服务器获取HTML后，会**完整解析所有HTML标签**（包括`<script>`、`<link>`、`display: none`的元素、注释等），生成一棵完整的DOM树。

- **为什么要完整？**

    - DOM树是JS操作页面的基础（比如你可以用JS把`display: none`的元素改成`display: block`，如果DOM树里没有它，就没法操作了）。

    - 即使元素暂时不可见，也可能通过CSS动画、用户交互等动态显示，浏览器必须提前知道它的存在。

#### 2. 渲染树（Render Tree）：有选择地构建，只留「可见元素」

- **生成方式**：DOM树生成后，浏览器会结合CSSOM树（CSS解析生成的样式树），**筛选出需要在页面上显示的元素**，生成渲染树。

- **哪些元素会被排除在渲染树之外？**（核心筛选规则）

    1. **`display: none`** **的元素**：完全从渲染树中移除，既不占空间，也不显示（这就是为什么`display: none`会导致页面重排，而`visibility: hidden`不会——因为`visibility: hidden`的元素还在渲染树里，只是看不见，占着空间）。

    2. **非视觉元素**：比如`<script>`、`<link>`、`<meta>`、`<style>`（除非是内联样式且影响布局）、注释等，这些元素没有视觉表现，不会进入渲染树。

    3. **内容完全被遮挡的元素？**（特殊情况）：如果一个元素被另一个元素完全覆盖（且覆盖元素不透明），浏览器可能会在**绘制阶段**优化掉它的绘制，但它仍会在渲染树里，因为布局阶段需要计算它的位置（避免影响其他元素）。

---

### 二、渲染流程中的「选择性」：从渲染树到屏幕

渲染树生成后，浏览器会经过**布局（Layout）→ 绘制（Paint）→ 合成（Composite）** 三个阶段，每个阶段都有「选择性优化」：

#### 1. 布局阶段（Layout/Reflow）：计算可见元素的位置和大小

- 只对**渲染树中的元素**进行布局，计算它们的几何信息（宽、高、位置等）。

- **现代浏览器的优化**：

    - **增量布局**：只重新布局发生变化的元素（比如你修改了一个元素的宽度，只会重新布局它和它的子元素，不会整个页面重排）。

    - **视口外延迟布局**：对于视口（屏幕可见区域）外的元素，浏览器可能会延迟布局，等用户滚动到附近时再计算（避免浪费性能在不可见的内容上）。

#### 2. 绘制阶段（Paint/Repaint）：把元素画到像素上

- 只绘制**渲染树中且在视口内的元素**。

- **现代浏览器的优化**：

    - **分层绘制**：把页面分成多个层（Layer），每个层独立绘制，最后合成（比如动画元素会单独分层，避免重绘整个页面）。

    - **增量绘制**：只重新绘制发生变化的层或区域（比如你修改了一个元素的颜色，只会重绘它所在的层）。

#### 3. 合成阶段（Composite）：把多个层合成到屏幕上

- 只合成**可见的层**，对于被完全遮挡的层，浏览器可能会跳过合成。

- **现代浏览器的优化**：利用GPU加速合成，把层交给GPU处理，提升性能（比如CSS动画、`transform`、`opacity`会触发GPU加速）。

---

### 三、举个直观的例子

假设HTML结构是这样的：

```HTML

<div class="container">
  <div class="visible">我是可见的</div>
  <div class="hidden" style="display: none;">我是display: none的</div>
  <div class="invisible" style="visibility: hidden;">我是visibility: hidden的</div>
  <script>console.log('我是script')</script>
</div>
```

- **DOM树**：包含`container`、`visible`、`hidden`、`invisible`、`script`所有元素。

- **渲染树**：只包含`container`、`visible`、`invisible`（`hidden`和`script`被排除）。

- **布局阶段**：计算`container`、`visible`、`invisible`的位置和大小（`invisible`占空间，但看不见）。

- **绘制阶段**：只绘制`visible`（`invisible`不绘制，`hidden`和`script`根本不在渲染树里）。

---

### 四、总结

1. **DOM树**：完整解析所有HTML元素，一个都不能少（为了JS操作和动态变化）。

2. **渲染树**：有选择地构建，只包含**可见元素**（排除`display: none`、非视觉元素等）。

3. **布局/绘制/合成**：进一步优化，只处理**渲染树中且在视口内的元素**，利用增量更新、分层绘制、GPU加速等提升性能。

简单说就是：**浏览器「心里有数」（完整DOM树），但「只做有用的」（选择性渲染可见内容）**。
> （注：文档部分内容可能由 AI 生成）